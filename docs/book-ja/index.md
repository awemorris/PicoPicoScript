# はじめに

本書をお手に取っていただきありがとうございます。本書は、PlayfieldVM / PicoPicoScript というソフト（以下、ピコスク）を使ってゲームプログラミングを学ぼう、という趣旨の書籍です。読者は小学校高学年以上を幅広く想定しており、プログラミングを初めて学ぶことを前提としています。

どんなプログラミング言語でプログラミングを始めるかということは、いつの時代にも大きな悩みの種ですよね。特に２０２０年代には、Ruby, Python, JavaScript など、魅力的な言語がいくつもあります。そんな中でピコスクは、覚えやすさと使いやすさを重視したプログラミング言語として、日本発の誰でも無料で自由に使えるオープンソースソフトウェアという形で登場しました。

ピコスクは、筆者が初心者にプログラミングを教える中で感じた、いろいろな課題を解決するために開発されました。

- サイズの小さな実行ファイルが１つあれば動き、環境構築を即座に終えられる
- シンプルな文法で、かんたんな説明があれば全体を理解できる
- 主流のプログラミング言語と似た文法で、他のプログラミング言語への応用が効く
- 文字だけでなく絵や音を簡単に出すことができ、使っていて楽しさがある
- 本格的なゲーム開発に利用でき、他のプログラミング言語を覚えなおす必要がない
- 作った作品をスマートフォンやタブレットに転送でき、人に見せられる
- 作った作品をZIPで他の人にかんたんに配布できる

今から３０年から４０年前、パソコンの黎明期には、BASIC という初心者用のプログラミング言語を使って、かんたんなゲームを作る文化が育っていました。まだインターネットが一般的でなかったころですから、雑誌に載っているゲームプログラムを書き写して自分のパソコンで遊ぶ若者の姿が日本の至るところで見られました。その後、パソコンがだんだん複雑で高度になっていき、BASIC では制御できなくなったことで、昔ほどかんたんにはゲームが作れなくなり、初心者がゲームを通してプログラミングを学ぶ文化が衰退していったように思います。実は、ピコスクのかんたんさは BASIC に比類するものではないかと考えています。それでいて、現代のハードウェアに即したゲームを作ることができます。ピコスクが再び、プログラミング初心者がゲームを作って学ぶという文化を形成してくれたらなと、切に思います。

ピコスクは、名前は少しばかりゆるいのですが、技術的に見れば研究レベルで高度な言語処理系であり、その言語仕様も王道のものとなっています。ピコスクで覚えたことは、ピコスクを卒業して他のプログラミング言語を使うときにもそのまま応用できますので、安心して学んでいただければと思います。もちろん、ピコスクを末永く利用していただければ、開発者としてこれ以上うれしいことはありません。

ともあれ、本書、そしてピコスクを通して、プログラミングが楽しいと思う気持ちを育てていただけましたら、この上ない幸いです。

---

# まずは動かしてみよう

→CAN DO: ピコスクを動かす

ここでは「ピコスクを手に入れて」「実行して」「ちょっとだけ自分で改造してみる」ところまでを体験します。
初めての人でもつまずかないように、一歩ずつ順番に進めていきましょう。

## ピコスクを手に入れる

ピコスクは無料で公開されています。公式ページ（GitHub）からダウンロードしましょう。

→ダウンロード先
[https://github.com/awemorris/PlayfieldVM](https://github.com/awemorris/PlayfieldVM)

ダウンロードした ZIP ファイルを展開すると、いくつかのフォルダができます。
２０２５年現在、多くのユーザは Windows 11 を利用していると思いますので、ここでは Windows 11 を前提に進めます。

## 実行ファイルをみつける

展開したフォルダの中に windows-x86_64 というフォルダがあります。
その中に `playfield` というアイコンがあるはずです。
これがピコスク本体です。

ヒント：`playfield` は、このファイル１つがあればそれだけで動きます。ほかの Windows PC にコピーしてもそのまま動作します。

## 動かしてみる

`playfield` をダブルクリックして動かしてみましょう。
正しく動作すれば、水色の箱がウィンドウの中を跳ね回る画面（ウィンドウ）が出てきます。

「とりあえず動いた！」という瞬間です。ここまで来れば成功です！

ヒント：最近のパソコンは６４ビットですが、もし古い３２ビットのパソコンを利用していて、`playfield` が動かなかった場合は、`windows-x86` というフォルダに入っている `playfield` であれば動くかもしれません。

## 初めての改造

次に、ちょっとした「魔法」をかけてみましょう。
`playfield` と同じフォルダにある `main.noct` というファイルをダブルクリックして、メモ帳で開いてください。
そこにプログラムが書かれています。

その中に次の部分があります。

```
// Create a texture.
tex = Engine.createColorTexture({
    width: BLOCK_W,
    height: BLOCK_H,
    r: 0,
    g: 128,
    b: 255,
    a: 255
});
```

ここで、`r`, `g`, `b` が色の指定になっています。（赤＝Red、緑＝Green、青＝Blue）
数字はそれぞれの色の強さで、0 〜 255 の範囲で指定します。

試しに、次のように変えて保存してみましょう。

```
r: 255,
g: 0,
b: 0,
```

もう一度 `playfield` と実行すると……赤い箱が出てきましたね！

ヒント：コンピュータで色を指定するときには、RGB の３つの色の強さを使うことが一般的です。RGB のことを「光の三原色」といって、３つの色の光を組み合わせて、すべての色を表現することが可能です。

## まとめ

この章では：

- ピコスクを入手して動かす
- プログラムを少し書き換えて結果を確認する

までを体験しました。

次の章では、さらに自分のアイディアを形にする方法を学びます。

---

# プログラミングの基本

この章では一般的なプログラミングの基本について解説します。
ここで解説することは、ピコスクに限ったことではなく、ほとんどのプログラミング言語で共通のことです。

## Hello World

ピコスクをダウンロードして展開したフォルダの中にある `SAMPLES` フォルダを開いてみてください。

---

# ピコスクのプログラムの構成

この章では、前章の文字表示からステップアップして、ピコスクで絵を表示したり、音を再生したりするプログラムの書き方を学びます。

前章までで学んだ通り、多くのプログラミング言語では、関数（かんすう）と呼ばれる単位でプログラムを書きます。ピコスクでは、`setup`, `start`, `frame` の３つの関数を書くことで、ゲームを作ります。

`playfield` と同じフォルダに入っている `main.noct` を開いてみます。このプログラムを眺めてみると、`setup`, `start`, `frame` の３つの関数でできていることがわかると思います。

## setup 関数

`setup` 関数の中身を見てみると、次のようになっています。`func` というのが関数の定義の目印で、`function` つまり英語で関数の略です。

```
func setup() {
    return {
        width: 800,
        height: 450,
        title: "Bouncer"
    };
```

この `setup` 関数は、ピコスクの起動時に一度だけ実行されるものです。関数には呼び出し元、呼び出し先という考え方があり、この `setup` 関数の場合だと、ピコスクのシステムが呼び出し元で、`setup` 関数が呼び出し先になります。`setup` 関数は呼び出されると、呼び出し元であるピコスクのシステムに対して、ゲームの設定を返します。

設定というのは、画面表示に関わる重要な決めごとのことです。ここでは、プログラムの画面表示を 800×450 というサイズで行うことと、ウィンドウの名前を `Bouncer` にするという決めごとを行っています。

## start 関数

次に出てくる `start` という関数は、ピコスクがプログラムに準備を行ってほしいときに１回だけ呼び出されます。ここでは、色のついた箱の画像を作る処理を行っています。

```
func start() {
    W = 800;
    H = 450;
    BLOCK_W = 48;      // pixels
    BLOCK_H = 48;      // pixels
    SPEED_X = 180.0;   // pixels/sec
    SPEED_Y = 140.0;   // pixels/sec
    MAX_DT  = 0.1;     // sec

    // Create a texture.
    tex = Engine.createColorTexture({
        width: BLOCK_W,
        height: BLOCK_H,
        r: 0,
        g: 128,
        b: 255,
        a: 255
    });

    // Set the initial block position.
    x = (W - BLOCK_W) * 0.5;
    y = (H - BLOCK_H) * 0.5;

    // Set the initial speed.
    vx = SPEED_X;
    vy = SPEED_Y;

    last_ms = Engine.millisec;
}
```

## frame 関数

最後に出てくる `frame` という関数は、１秒間に６０回、画面を書き換えるたびに呼び出されるものです。ここでは、箱の移動と描画（画面に絵を描くこと）を行っています。

```
func frame() {
    var now_ms = Engine.millisec;
    var dt = (now_ms - last_ms) * 0.001;
    last_ms = now_ms;

    // Process the input.
    if (Engine.isMouseLeftPressed) {
        x = (W - BLOCK_W) * 0.5;
        y = (H - BLOCK_H) * 0.5;
    }

    // Update the position
    x = x + vx * dt;
    y = y + vy * dt;

    // Reflect.
    if (x < 0) {
        // Left to right.
        x = -x;
        vx = -vx;
    } else if (x > W - BLOCK_W) {
        // Right to left.
        x = 2*(W - BLOCK_W) - x;
        vx = -vx;
    }
    if (y < 0) {
        // Up to down.
        y = -y;
        vy = -vy;
    } else if (y > H - BLOCK_H) {
        // Down to up.
        y = 2*(H - BLOCK_H) - y;
        vy = -vy;
    }

    // Draw.
    Engine.draw({
        texture: tex,
        x: x,
        y: y
    });
}
```
